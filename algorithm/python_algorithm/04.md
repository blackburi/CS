# 스택

## stack
* 스택의 특성
    * 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조이다.
    * 스택에 저장된 자료는 **선형구조**이다.
        * 선형 구조 : 자료 간의 관계가 1대 1의 관계를 갖는다.
        * 비선형 구조 : 자료 간의 관계가 1대 N의 관계를 갖는다. (ex. 트리)
    * 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
    * 마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(LIFO, Last-In-First-Out)이라고 부른다.
        * 예를 들어 1, 2, 3 순으로 자료를 삽입한 후 꺼내면 역순으로 3, 2, 1 순으로 꺼낼수 있다.
* 스택을 프로그램에서 구현하기 위해서 필요한 자료구조와 연산
    * 자료구조 : 자료를 선형으로 저장할 저장소
        * 배열을 사용할 수 있다.
        * 저장소 자체를 스택이라고 부르기도 한다.
        * 스택에서 마지막 삽입된 원소의 위치를 top이라고 부른다.
    * 연산
        * 삽입 : 저장소에 자료를 저장한다. 보통 push라고 한다.
        * 삭제 : 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 pop이라고 부른다.
        * 스택이 공백인지 아닌지를 확인하는 연산 : isEmpty
        * 스택의 top에 있는 item(원소)을 반환하는 연산 : peek
        * 스택이 가득찼는지 확인하는 연산 : isFull
* 스택의 삽입/삭제 과정

    ![push and pop of stack](../image/stack.gif)

* 스택 구현 고려 사항
    * 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점이 있다.
    * 이를 해결하기 위한 방법으로 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다. 동적 연결리스트를 이용하여 구현하는 방법을 의미한다. 구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장점을 가진다.

* function call
    * 프로그램에서의 함수 호출과 복귀에 따른 수행순서를 관리
        * 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행 순서 관리
        * 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입
        * 함수의 실행이 끝나면 시스템 스택의 top원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
        * 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 된다.

    ![function call](../image/function_call.png)


## 재귀호출
* 필요한 함수가 자신과 같은 경우 자신을 다시 호출하는 구조
* 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀 호출 방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성 가능
```python
# factorial - for구문
fac = 1
if n == 0 :
    print(1) # 0! == 1
else : # n != 0
    for i in range(1, n+1) :
        fac *= i
    print(fac) # n!

# factorial - 재귀
def factorial(n) :
    global fac
    if n == 0 :
        return 1
    elif n == 1 :
        return fac
    else : # n != 0
        fac *= n
        return factorial(n-1)
fac = 1
print(factorial(5)) # 120
```
```python
# 피보나치 수열 - 재귀
def fino(n) :
    if n < 2 :
        return n
    else : # n >= 2
        return fibo(n-1) + fibo(n-2)
```


## Memoization
* 재귀함수로 피보나치 수열을 구현할 경우 **엄청난 중복 호출이 존재**한다는 문제가 발생한다.
* memoization은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다.
```python
# 피보나치 수열 - memoization
n = int(input()) # n == 5

def fibo(n) :
    global memo
    if n >= 2 and memo[n] == 0 :
        memo[n] = fibo(n-1) + fibo(n-2)
    return memo[n]

memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1
print(fibo(n)) # 5
```


## DP
* Dynamic Programming = 동적 계획
* 동적 계획 알고리즘은 그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즘 이다.
* DP는 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 문제들을 해결하여 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.
* DP의 과정
    1. 문제를 부분문제로 분할한다.
    2. 부분 문제로 나누는 일을 끝냈다면 가장 작은 부분 문제부터 해를 구한다.
    3. 그 결과를 저장하고, 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구한다.
* DP의 조건
    * 작은 문제가 **반복**적으로 일어나는 경우
        * Divide and Conquer(분할정복)와 다른 부분은 동일하지만 DP는 반복적으로 일어난다는 차이점이 있다.
    * 같은 문제는 구할 때마다 정답이 같다.
* memoization을 반복적 구조로 DP를 구현하는 것이 성능면에서 효율적이다.