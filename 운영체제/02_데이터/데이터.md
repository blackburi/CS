# 데이터


## 0과 1로 숫자를 표현하는 방법

### 정보 단위
* 비트(bit)
    * 0과 1을 나타내는 가장 작은 정보 단위
* 바이트(byte)
    * 1byte = 8bit
    * 2^8 = 256개의 정보를 표현할 수 있음
* 킬로바이트(kB : kilobyte)
    * 1kB = 1000byte
* 메가바이트(MB : megabyte)
    * 1MB = 1000kB
* 기가바이트(GB : gigabyte)
    * 1GB = 1000MB
* 테라바이트(TB : terabyte)
    * 1TB = 1000GB
<hr>

* KiB, MiB, GiB, TiB
    * 1000개가 아닌 1024개씩 묶어 표현한 단위

<hr>

* 워드(word)
    * CPU가 한번에 처리할 수 있는 데이터의 크기
        * ex) CPU가 한 번에 16비트를 처리할 수 있다면 1워드=16비트, CPU가 한 번에 32비트를 처리할 수 있다면 1워드=32비트
    * 워드의 크기에 따른 정의
        * 하프 워드(half word) : 절반 크기
        * 풀 워드(full word) : 1배 크기
        * 더블 워드(double word) : 2배 크기
    * ex) 인텔의 x86 CPU는 32비트 워드 CPU, x64 CPU는 64비트 워드 CPU

### 이진법 (binary)
* 0과 1만으로 모든 숫자를 표현하는 방법 -> 이진법으로 표현한 수를 이진수 라고 한다.
* 이진수의 표기 : 이진수 끝에 아래첨자 `(2)`를 붙이거나 이진수 앞에 `0b`를 붙인다. 전자의 경우 주로 수학적으로 표기할 때, 후자의 경우 주로 코드 상에서 이진수를 표기할 때 사용된다.
* 음수 표현 : 2의 보수(two's complement)
    * 사전적 정의 : 어떤 수를 그보다 큰 2^n에서 뺀 값
        * 11(2)의 2의 보수는 11(2)보다 큰 2^n, 즉 100(2)dptj 11(2)를 뺀 01(2)가 되는 것이다.
    * 이해한 2의 보수 : 모든 0과 1을 뒤집고 1을 더한 값
        * 11(2)의 모든 0과 1을 뒤집으면 00(2), 여기에 1을 더하면 01(2)가 된다.
    * 그러나 2의 보수만으로는 음수를 확인하기 어렵다 -> 0101(2)가 양수인지 음수인지 알 수 없다 -> 플래그(flog)를 사용
    * 2의 보수의 한계 : 0이나 2^n의 값은 원하는 음수값을 얻을 수 없다.
        * 0000(2)의 2의 보수는 10000(2), 1000(2)의 2의 보수는 자기자신(1000(2))가 된다. 즉 n비트는 2^n, -2^n을 동시에 표현할 수 없다. 0의 경우는 1을 버려도 무방하다. 결국 -0도 0이기 때문이다.

### 십육진법(hexadecimal)
* 이진법의 경우 숫자의 길이가 너무 길어진다는 단점이 있기 때문에 십육진법도 자주 사용한다. 10부터는 A부터 알파벳을 사용한다.
* 십육진수의 표기 : 아래첨자 `(16)`을 붙이거나 `0x`를 붙인다.
* 십육진법을 사용하는 이유 : 컴퓨터는 이진법을 사용하는데 이진법과 십진법을 변환하기는 어렵지만 이진법과 십육진법을 변환하는 것은 쉽기 때문이다.