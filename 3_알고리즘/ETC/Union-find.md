# Union Find

* 집합들의 합집합과 같은 집합 연산을 효율적으로 처리하기 위해 사용되는 자료 구조
* 주로 연결성을 파악하고나 최소 신장 트리를 구하는 등의 문제에서 응용됨

## 기본 연산
1. <a>Find</a>
    * 어떤 원소가 속한 집합을 찾는 연산
    * 해당 원소가 속한 집합의 "대표자" 혹은 "루트"를 찾는 것을 목표로 한다.
2. <a>Union</a>
    * 두 개의 집합을 하나의 집합으로 합치는 연산
    * 두 집합의 대표자를 찾아 하나의 다른 하나의 부모로 설정함으로써 두 집합을 합친다.

## 알고리즘의 최적화
Union-Find 알고리즘의 기본 구현은 간단하지만, 대규모 데이터에 대해서는 두 가지 중요한 최적화 기법이 적용됨
<br>
1. <a>경로 압축</a>(Path Compression)
    * Find 연산을 수행할 때, 찾은 루트까지의 경로에 있는 모든 노드들을 직접 루트에 연결하여, 향후 같은 집합의 원소를 찾을 때 시간을 단축시킨다.
2. <a>랭크 기반 합치기</a>(Union by Rank)
    * 두 트리를 합칠 때, 높이(랭크)가 낮은 트리를 높이가 높은 트리 밑에 붙여, 합친 후의 트리 높이를 가능한 낮게 유지하여, Find의 시간 복잡도를 개선한다.

## 시간 복잡도
최적화 기법을 사용했을 경우, Union-Find 알고리즘의 모든 연산은 O(a(n)), 최악의경우 O(n)을 넘지 않는다. 이때 a(n)은 아커만 함수의 역함수를 의미한다.
즉, 상수 시간에 가까운 수행 시간을 갖는다.

## 코드 구현
```python
def init(n) :
    parent = [i for i in range(n+1)]
    return parent

# 부모 node가 있다면 갱신해주는 함수
def find(x) :
    if parent[x] != x :
        # 반드시 부모 노드를 갱신해주어야 한다.
        parents[x] = find(parents[x])
    return parents[x]

# 부모 node가 다르다면 합쳐주는 함수
def union(x, y) :
    x = find(x)
    y = find(y)

    # 작은 수를 부모 node로 두지만 문제 조건에 의해 바뀔수 있음
    if x > y :
        parent[x] = y
    else :
        parent[y] = x
```