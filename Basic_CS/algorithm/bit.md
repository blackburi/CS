# bit 비트

## 부분집합 생성
* 부분집합
    * 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 개수는 `2**n`개이다.
    * 각 원소를 포함하거나 포함하지 않는 2가지 경우를 모든 원소에 적용시킨 결과이다.
    * 각 원소가 부분집합에 포함되어 있는지 loop를 이용하여 확인하고 부분집합을 생성하는 방법
        ```python
        bit = [0, 1, 2, 3]
        for i in range(2) :
            bit[0] = i : # 0번 원소
            for j in range(2) :
                bit[1] = j # 1번 원소
                for k in range(2) :
                    bit[2] = k # 2번 원소
                    for l in range(2) :
                        bit[3]  l # 3번 원소
                        print_subset(bit) # 생성된 부분집합 출력
        ```

## bit
* bit의 이해
    * 기본 이해 : 리스트 A가 존재할 때, 리스트의 인덱스를 2의 거듭제곱으로 나타낸다. 이때 인덱스의 합을 기준으로 부분집합을 나타내는 방식으로 이해를 하면 된다. 2의 거듭제곱의 합으로 숫자를 나타내는 방법은 유일하기 때문에 숫자 한개당 부분집합을 표현하는 방법이 유일하다.
        * 이때 index의 지수(2의 거듭제곱의 지수)가 실제 python에서의 index가 된다.
    * 응용 이해 :똑같은 방식으로 거꾸로 사용하여 원하는 값만 가져오는 것 또한 가능하다. 내가 원하는 부분집합의 원소들의 index를 합쳐서 하나의 2진법 수로 나타낸다면 그것은 유일한 부분집합을 나타내는 경우다.
    * 이렇게 생각해도 부분집합은 원소가 n개 일 때, `2**n`의 부분집합을 갖는다.
    ```python
    # 기본 이해
    
    # 원소 리스트
    my_list = [a, b, c, d]
    # 원소의 index를 2의 거듭제곱으로 생각
    my_indx = [1, 2, 4, 8]
    # 순서는 2의 거듭제곱, 이때 거듭제곱의 지수가 실제 python에서의 index와 동일하다.

    # 14 = 2 + 4 + 8 => 1110(2) : 14
    # [b, c, d]를 나타내는 수가 14가 된다. (2진법 기준)
    ```
    ```python
    # 응용 이해

    # 원소의 개수가 n개라면 0~(2**n-1)까지 부분집합을 의미하는 숫장이다.
    # 하나의 숫자로 원하는 배열을 가져올 수 있다.

    # 원소 리스트
    my_list = [a, b, c, d]
    # 원소의 index를 2의 거듭제곱으로 생각
    my_indx = [1, 2, 4, 8]

    # 14 = 8 + 4 + 2 = 1110(2)
    # 따라서 이 경우 부분집합은 [b, c, d]를 나타낸다.
    ```
    * '기본 이해'의 경우 내가 부분집합을 전부 원한다면 전부 만들어두고 생각하는데 용이하다. '응용 이해'는 내가 원하는 부분집합을 뽑고 싶다면 그것을 숫자로 나타내거나 처음부터 전부 만들 필요가 없고 바로 호출 하면 된다.
* bit 연산자
    * `&` : bit 단위로 AND 연산을 한다.
        * `i&(1<<j)` : i의 j번째 비트가 1인지 아닌지를 검사한다.
    * `|` : bit 단위로 OR 연산을 한다.
    * `<<` : 피연산자의 bit 열을 왼쪽으로 이동시킨다.
        * `1<<n` : 2**n 즉, 원소가 n개일 경우의 모든 부분집합 수를 의미한다.
        * `a<<b` : `a * (2**b)` 를 의미한다.
    * `>>` : 피연산자의 bit 열을 오른쪽으로 이동시킨다.
        * `a>>b` : `a * (0.5**b)` 를 의미한다.
* bit를 이용하여 간결하게 부분집합을 생성하는 방법
    ```python
    arr = [3, 6, 7, 1, 5, 4]

    n = len(arr) # 원소의 개수

    for i in range(1<<n) : # 1<<n : 부분집합의 개수
        for j in range(n) : # 원소의 수만큼 비트를 비교
            if i & (1<<j) : # i의 j번 비트가 1인경우
                print(arr[j], end=" ") # j번 원소 출력
        print()
    print()
    ```