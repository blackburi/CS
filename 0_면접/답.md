#  네트워크 기초 및 실무 적용

### TCP와 UDP의 차이점과 각각이 사용되는 사례를 설명하시오.
```md
* TCP : Transmission Control Protocol
    * 연결지향형(connected) 프로토콜로, 통신을 시작하기 전 3-way handshake를 통해 연결을 설정. 수신 여부를 확인하고 패킷 순서를 유지하며, 손실된 데이터는 재전송되기 때문에 데이터 전송의 신뢰성을 보장.
    * 웹 페이지 요청(HTTP/HTTPS), 파일 다운로드(FTP), 이메일 전송(SMTP), DB통신 등
* UDP : User Datagram Protocol
    * 비연결형(connectionless) 프로토콜로, 연결 설정 없이 데이터를 전송. 연결 설정 없이 데이터를 전송하며, 속도가 빠르지만 신뢰성이 낮음. 순서 보장이나 재전송 기능이 없어 오버헤드는 적지만, 패킷 손실이 발생해도 복구하지 않음
    * 실시간 스트리밍, 온라인 게임, 인터넷 전화(VoIP - zoom, discord 등), DNS 요청
```

<br>

* DNS : Domain Name System
    * 사람이 기억하기 쉬운 도메인 주소(www.example.com)를 컴퓨터가 이해할 수 있는 IP 주소(123.45.67.89)로 바꿔주는 인터넷 전화번호부 같은 시스템
    * DNS 오류가 나면 사이트 접속 자체가 안됨. CDN, 로드밸런서, 도메인 연결 등에서도 필수적으로 사용됨

<hr>

### HTTP와 HTTPS의 차이점과 HTTPS가 보안에 어떻게 기여하는지 설명하시오.
```md
* HTTP : HyperText Transfer Protocol
    * 데이터를 평문(암호화되지 않은 상태)으로 전송하므로, 네트워크 상에서 도청이나 위변조의 위험이 있음.
* HTTPS : HyperText Transfer Protocol Secure
    * HTTP에 SSL/TLS 암호화 계층이 추가된 프로토콜로, client와 server 간 통신 내용을 암호화하여 기밀성, 무결성, 인증성을 제공. 서버 인증서를 통해 서버의 신원 확인이 가능하고, 중간자 공격(MITM)을 방지할 수 있음
```

<br>

* SSL/TLS 암호화 계층
    * SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 인터넷에서 데이터를 안전하게 암호화해서 전송하기 위한 보안 프로토콜. 즉 서버와 클라이언트 사이의 데이터를 중간에 훔쳐보거나 조작하지 못하도록 보호하는 역할.
    * SSL은 더이상 사용하지 않고 TLS를 사용. TLS가 더 안전함
    * TLS : 암호화, 무결성, 인증
* TLS 통신 흐름
    1. client가 server 접속
    2. server가 TLS 인증키(공개키 포함)를 client에게 전송
    3. client는 인증서가 신뢰할수 있는 기관(CA)에서 발급됐는지 확인
    4. client는 대칭키를 암호화해서 server에 전달
    5. server는 비공개키로 복호화(데이터를 원래 상태로 되돌리는 것)
    6. 이후 모든 통신은 암호화된 대칭키 기반으로 이루어짐(빠르고 안전)


<hr>

### HTTP 1.1과 HTTP 2.0의 차이를 설명하시오.
|항목|HTTP/1.1|HTTP/2|
|:---:|:---:|:---:|
|연결당 요청|1개|여러 개(멀티플렉싱)|
|HOL Blocking|존재|제거됨|
|헤더 압축|없음|HPACK 압축|
|서버 푸시|없음|있음|
|속도|느림|빠름|

<br>

* HOL Blocking (Head-of-Line Blocking)
    * 앞줄 요청이 처리되기 저까지, 뒷줄 요청이 대기하게 되는 문제
    * HTTP/1.1에서 HTML 요청이 끝나야 CSS 요청을 보냄
    * HTTP/2.0에서 멀티플렉싱으로 해결
* 서버 푸시 (Server Push)
    * client가 요청하지 않은 자원(css, js 등)을 서버가 먼저 밀어주는(보내주는) 기능
* HTTP/3.0
    * HTTP/2는 TCP 기반으로 멀티플렉싱이 가능하지만, 하나의 패킷 손실이 전체 요청에 영향을 주는 HOL Blocking 문제는 여전히 존재. 이를 해결하기 위해 등장한 HTTP/3는 UDP 기반의 QUIC 프로토콜을 사용하여, 지연 시간을 줄이고, 빠른 재전송 및 연결 복구가 가능. 특히 모바일 환경에서 네트워크가 끊겼다가 다시 연결될 때의 회복 속도가 빨라 실시간성에 강점을 가집니다.

<hr>

### REST API란 무엇이며, RESTful하지 않은 API는 어떤 특징을 가지는가?
```md
* REST API
    * client와 server가 정해준 규칙에 따라 통신하는 방식
    * 주소는 무엇을 요청할지를, 요청 방식(GET, POST, PUT, PATCH, DELETE)은 무슨 행동을 할지를 정하는 것
* RESTful하지 않은 API
    * 주소에 동작을 직접 써버리는 경우
    * 조회를 POST로 하는 방식
* RESTful API
    * 규칙이 명확하여 예측이 쉽고, 협업이나 유지 보수에 유리
```

<br>

|항목|PUT|PATCH|
|:---:|:---:|:---:|
|의미|전체 자원 수정(덮어쓰기)|일부 필드만 부분 수정|
|특징|기존 자원을 통째로 바꿈|자원의 일부 속성만 수정|
|요청 body|전체 자원 정보 포함|변경할 필드만 포함|


<hr>

### CORS란 무엇이며, 왜 필요한가?
```md
* CORS : Cross-Origin Resource Sharing
    * 브라우저 보안 정책 : 서로 다른 출처(도메인/포트/프로토콜)의 server에 client가 요청을 보낼 때 발생할 수 있는 문제를 다룸
* CORS가 필요한 이유
    * 보안 : 다른 사이트에서 내 브라우저의 정보를 몰래 요청하는 것을 방지
    * 브라우저 보호 : 내 브라우저가 악성 사이트에 속아 내 쿠키나 토큰을 외부로 전송하지 않도록 방지
    * 서버 측 허용 필요 : 요청을 허용하려면 서버가 직접 허용 설정(Access-Control-Allow-Origin)을 해야 함
```

<br>

예를 들어, https://a.com에서 실행 중인 웹 앱이 https://b.com API에 요청을 보낼 경우, 브라우저는 이를 다른 출처(Origin)로 간주하고, 명시적으로 허용된 요청만 수행. 이때 b.com 서버가 응답 헤더에 `Access-Control-Allow-Origin: *` 또는 특정 도메인을 설정해야만 요청이 허용됩니다.

<hr>

### 로드 밸런서의 역할과 Round Robin 방식 외에 다른 분산 전략을 설명하시오.

<hr>

### 웹에서 브라우저가 서버에 요청을 보내고 응답받기까지의 흐름을 설명하시오.

<hr>

### DNS가 어떻게 동작하는지 설명하시오.

<hr>

### Keep-Alive는 무엇이며 어떤 상황에서 유리한가?

<hr>

### 웹소켓과 일반 HTTP의 차이점과 각각의 용도를 설명하시오.
```md
HTTP는 클라이언트 요청에 대해 서버가 응답하는 단방향 구조이며, 요청이 있을 때만 서버가 응답할 수 있습니다. 반면 WebSocket은 최초 연결 시 HTTP 핸드셰이크를 거친 후 TCP 기반으로 양방향 지속 연결을 유지하여, 서버와 클라이언트가 자유롭게 데이터를 주고받을 수 있습니다. HTTP는 실시간성이 낮아 실시간 데이터 전송 시 주기적 요청(Polling)이나 롱 폴링이 필요해 부하가 증가할 수 있습니다. WebSocket은 별도의 요청 없이도 서버가 즉시 데이터를 Push할 수 있어 지연이 적고 효율적입니다. 일반 API 호출·정적 페이지 요청 등 단순 요청-응답에는 HTTP가 적합하며, 채팅·주식 시세·실시간 알림처럼 지속적이고 빠른 데이터 교환이 필요한 서비스에는 WebSocket이 적합합니다.
```

<br>

|항목|HTTP|WebSocket|
|:---:|:---:|:---:|
|연결 방식|요청-응답(단방향)|양방향|
|연결 유지|요청마다 새 연결|연결 지속|
|실시간성|낮음(Polling 필요)|높음(즉기 push 가능)|
|메시지 흐름|Client → Server → Response|Client ⇄ Server|
|대표 용도|API, 페이지 요청|채팅, 게임, 실시간 데이터|


<hr>

### 캐시(Cache)를 사용하는 이유와 주의할 점은?
```md
캐시는 자주 사용되는 데이터를 메모리에 저장하여 데이터베이스나 원본 서버 접근을 줄이고 응답 속도를 향상시키는 기술이다. 예를 들어 로그인한 사용자 정보, 인기 상품 목록 등을 캐시에 저장하면 성능과 확장성이 향상된다. 주의할 점은 데이터 갱신 시 캐시와 원본 간 불일치(Cache Invalidation) 문제, 캐시 용량 관리, TTL(Time To Live) 설정이다. 잘못된 캐시 전략은 오히려 데이터 불일치와 메모리 낭비를 초래할 수 있다.
```


<hr>



# 백엔드 실무 / 시스템 설계

### 단일 서비스가 아닌 MSA로 시스템을 분리할 때 얻는 이점과 주의할 점은?

<hr>

### MSA 간 통신에서 동기 vs 비동기 방식의 장단점을 비교하시오.

<hr>

### 트랜잭션이 필요한 작업에서 마이크로서비스 간 트랜잭션을 어떻게 보장할 수 있을지 설명하시오.

<hr>

### 대용량 트래픽이 들어오는 상황에서 서버 병목을 줄이는 방법을 설명하시오.

<hr>

### API 응답 속도가 느릴 때의 원인 분석 및 개선 방법을 설명하시오.

<hr>

### OAuth2 인증 방식과 JWT 토큰 기반 인증의 차이를 설명하시오.

<hr>

### 서버에서 비동기 작업을 처리할 때 어떤 방법을 사용할 수 있는지 설명하시오.

<hr>

### Webhook과 Polling의 차이를 설명하고 각각의 사용 예시를 드시오.

<hr>

### 배치 작업을 설계할 때 고려해야 할 요소를 설명하시오.

<hr>

### 파일 업로드와 같이 대용량 요청 처리를 위한 서버 설계 방식을 설명하시오.

<hr>


# 성능/안정성/보안/운영

### DB에서 인덱스를 생성할 때 고려할 점은 무엇인가요?

<hr>

### N+1 문제란 무엇이며, 어떻게 해결할 수 있나요?
N+1 문제는 한 번의 쿼리로 N개의 데이터를 조회한 후, 각 데이터에 연관된 정보를 가져오기 위해 N번의 추가 쿼리가 실행되는 비효율적인 데이터 조회 문제를 말한다. 예를 들어 게시글 목록을 조회한 후 각 게시글의 작성자 정보를 개별 쿼리로 가져오는 경우가 이에 해당한다. 해결 방법으로는 조인을 통한 한 번의 쿼리로 데이터 조회, JPA의 fetch join, Batch size 조정, 데이터 로더(DataLoader) 패턴 등이 있다. 이를 통해 불필요한 쿼리 호출을 줄이고 성능을 개선할 수 있다.

<hr>

### API Rate Limiting을 어떻게 구현할 수 있는지 설명하시오.

<hr>

### 캐시를 사용할 때의 장단점과 주의할 점을 설명하시오.

<hr>

### 서버의 메모리 사용량이 계속 증가한다면 어떤 원인을 의심하고 어떻게 분석할 것인가요?
메모리 사용량이 지속 증가하면 메모리 릭(객체 참조 누수), 캐시/버퍼의 무제한 성장(TTL/크기 미설정), 큐·스레드풀·연결풀의 비정상 누적, 파일/소켓 핸들 누수, 이미지/압축 등 네이티브(Off-heap) 메모리 누수, GC 비효율/파편화, 컨테이너 메모리 한도(cgroup) 오판 등을 의심한다.

분석은 (1) 재현 조건·배포 시점·트래픽 변화와의 상관 확인 (2) 프로세스 RSS/Heap 시계열 수집(top/ps, cAdvisor) (3) 힙/메모리 덤프로 대형 객체·참조 체인 파악(Java jmap/jcmd, Node heap snapshot, Python tracemalloc, Go pprof) (4) 캐시/큐/풀 지표 점검(TTL, 사이즈, 대기열) (5) FD/소켓 누수(lsof, /proc) (6) GC 로그/옵션 점검으로 원인 좁힌다.

대응은 누수 코드 수정, 캐시 LRU·TTL·사이즈 한도, 큐/스트림에 백프레셔·배치 크기 제한, 대용량 처리 스트리밍화, 풀 상한/타임아웃 설정, GC 튜닝 및 메모리 한도·알람 설정으로 재발을 방지한다.

<hr>

### 보안상 위험한 API 설계 패턴을 예시와 함께 설명하시오.

<hr>

### HTTPS를 사용하더라도 발생할 수 있는 보안 이슈를 설명하시오.

<hr>

### SQL Injection 공격이 어떻게 이뤄지고, 이를 방지하기 위한 방법을 설명하시오.

<hr>

### 로그를 저장하고 분석하는 방식과 실시간 모니터링을 위한 도구를 설명하시오.
저장 방식은 크게 <a>로컬 저장</a>과 <a>중앙집중형 저장</a>이 있다. 로컬 저장은 각 서버에 로그 파일을 남기는 단순 구조지만, 서버 수가 많으면 검색·집계가 어렵다. 중앙집중형 저장은 로그를 수집기(Fluentd, Logstash)로 모아 검색·분석 플랫폼(Elasticsearch, OpenSearch)에서 처리해 효율적이다.
분석 방식은 배치 분석(주기적 집계)과 실시간 분석(스트리밍 기반)이 있다. 실시간 모니터링 도구로는 ELK Stack(Elasticsearch + Logstash + Kibana), EFK Stack(Fluentd), Prometheus + Grafana 등이 대표적이다. 실무에서는 로그를 구조화(JSON 등)하여 저장하고, 검색·필터링 기준을 표준화해 장애 대응 속도를 높인다.

<hr>

### 시스템에서 장애가 발생했을 때 로그를 기반으로 원인을 분석하는 절차를 설명하시오.
1. 장애 범위와 영향도 파악 : 서비스 모니터링·알림 시스템에서 발생 시각, 영향받은 기능, 사용자 수를 확인한다.
2. 관련 로그 수집 : 서버·애플리케이션·DB·네트워크 등 계층별 로그를 같은 시간대 기준으로 수집하며, 타임존과 시각 동기화를 확인한다.
3. 이상 패턴 식별 : 에러 코드, 예외 스택, 응답 지연, 트래픽 급증 여부를 중심으로 로그를 필터링·검색한다.
4. 원인 추적 : 에러 발생 직전의 요청 흐름, 코드 변경 이력, 배포 기록을 함께 확인해 재현 가능성을 판단한다.
5. 재발 방지 조치를 설계 : 근본 원인에 대한 코드 수정·설정 변경·모니터링 강화 등 후속 조치를 문서화하고 공유한다.

<hr>


# 코드/테스트/협업/철학

### 좋은 API란 무엇이라 생각하며, 설계 시 가장 중요하게 생각하는 기준은?
좋은 API는 명확하고 일관성 있으며, 사용자가 예측 가능한 동작을 하는 API라고 생각한다.
1. 명확성 : 엔드포인트 이름, 파라미터, 응답 구조가 직관적이어야 하며, 문서 없이도 이해하기 쉬워야 한다.
2. 일관성 : 동일한 규칙을 모든 엔드포인트에 적용해 학습 비용을 최소화해야 한다. 예를 들어 CRUD 작업의 HTTP Method와 응답 형식은 항상 동일해야 한다.
3. 에러 처리가 명확 : 표준화된 응답 코드와 메시지로 호출자가 쉽게 원인을 파악하고 대응할 수 있어야 한다.
4. 확장성 : 새로운 기능 추가나 스키마 변경 시 기존 API를 깨뜨리지 않도록 버전 관리와 호환성을 고려해야 한다.
5. 성능과 보안 : 불필요한 데이터 전송을 줄이고, 인증·권한 관리를 통해 안전하게 호출할 수 있어야 한다.

<hr>

### 좋은 코드란 무엇이며, 본인의 코드 스타일을 한 문장으로 요약하시오.

<hr>

### 코드 리뷰를 할 때 가장 중요하게 보는 기준 3가지를 설명하시오.

<hr>

### 테스트 코드가 필요한 이유와, 어떤 방식의 테스트를 우선적으로 작성해야 하는지 설명하시오.

<hr>

### TDD의 장단점을 설명하시오.
```md
TDD(Test-Driven Development)는 테스트 코드를 먼저 작성한 후 기능을 구현하는 개발 방식
* 장점
    1. 요구사항을 명확히 정의하게 되어 설계 품질이 향상됨
    2. 테스트 자동화가 선행되므로 버그를 조기에 발견하고 유지보수가 용이.
    3. 리팩토링 시 기존 기능이 깨졌는지 쉽게 확인 가능
* 단점
    1. 초기 개발 속도가 느림
    2. 테스트 작성이 어려운 복잡한 기능에서는 테스트 코드 작성 부담이 커질 수 있음
    3. 테스트 품질이 낮으면 TDD의 장점이 퇴색됨
* 사용 여부
    * 모든 프로젝트에 무조건 적용하기보다, 핵심 로직이 중요하고 장기 유지보수가 필요한 서비스에서 효과적입니다.
```

<br>

|구분|TDD(Test-Driven-Development)|BDD(Behavior-Driven-Development)|Agile|Waterfall(폭포수)|
|:---:|:---|:---|:---|:---|
|핵심 개념|테스트 코드를 먼저 작성하고 기능 구현|시나리오 기반 테스트 작성 후 구현|짧은 주기 반복 개발과 지속 피드백|요구사항 → 설계 → 구현 → 테스트 → 배포 순차 진행|
|목표|코드 안정성과 설계 품질 향상|비즈니스 요구사항과 개발 간의 간극 축소|변화 대응력 강화, 고객 만족|계획에 따른 예측 가능한 개발|
|장점|- 버그 조기 발견 <br> - 리팩토링 안정성 증가 <br> - 설계 품질 증가|- 비개발자와 소통 용이 <br> - 요구사항 명확화|- 유연성 증가 <br> - 빠른 피드백 <br> 고객 중심|- 단계별 명확성 <br> - 문서화 잘됨|
|단점|- 초기 개발 속도 느림 <br> - 테스트 작성 부담|- 시나리오 작성 시간 증가 <br> - 복잡한 케이스 관리 어려움|- 문서화 부족 가능성 <br> 요구사항 잦은 변경 시 혼란|-변경 대응 어려움 <br> - 뒤늦게 버그 발견 가능성 있음|
|적합한 상황|핵심 로직이 중요하고 장기 유지보수가 필요한 서비스|기획/QA/개발 간 협업이 중요한 서비스|스타트업, 변화가 많은 서비스|명확한 요구사항, 변경 가능성이 낮은 프로젝트|
|산출물|단위 테스트 코드|시나리오 테스트|매 스프린트 별 릴리즈&회고|단계별 문서 및 최종 산출물|

<hr>

### CI/CD 파이프라인의 기본 구성과 장점을 설명하시오.
CI/CD는 Continuous Integration(지속적 통합)과 Continuous Delivery/Deployment(지속적 제공/배포)를 뜻하며, 코드 변경 사항을 자동으로 빌드, 테스트, 배포하는 파이프라인을 의미

* 기본 구성
    * 소스 저장소(예: GitLab, GitHub) – 코드 변경 사항 관리
    * CI 서버(Jenkins, GitLab CI) – 빌드와 테스트 자동화
    * 테스트 단계 – 단위/통합 테스트 실행
    * 배포 단계 – 스테이징/프로덕션 환경에 자동 배포
    * 모니터링 – 배포 후 서비스 상태 및 로그 모니터링
* 장점
    * 배포 속도 향상 : 코드 변경 후 빠르게 사용자에게 전달 가능
    * 품질 보장 : 자동 테스트로 버그 조기 발견
    * 일관성 확보 : 동일한 빌드/배포 절차로 환경 차이 최소화
    * 개발 효율성 증가 : 개발자는 코드 작성에 집중 가능

<hr>

### 본인이 주도적으로 서비스/코드를 개선한 경험을 구체적으로 작성하시오.

<hr>

### 협업 중 발생한 갈등 상황을 어떻게 해결했는지 경험을 바탕으로 설명하시오.

<hr>

### 서버 개발자로서 가장 중요하다고 생각하는 역량은 무엇이며, 그 이유는?
서버 개발자로서 가장 중요한 역량은 안정적이고 확장 가능한 시스템을 설계·구현하는 능력이라고 생각합니다. 서버는 단순히 요청을 처리하는 것에 그치지 않고, 대규모 트래픽·데이터 처리, 보안, 장애 복구까지 고려해야 합니다. 예를 들어, 트래픽 폭주 시에도 서비스가 중단되지 않도록 로드 밸런싱, 캐싱, 비동기 처리 등의 설계가 필요하고, 장애가 발생했을 때 빠르게 원인을 파악하고 복구할 수 있는 문제 해결 능력이 필수라고 생각하기 때문입니다. 이러한 역량을 갖추면 사용자는 안정적인 서비스를 경험하고, 개발팀은 서비스 품질과 운영 효율성을 높일 수 있습니다. 결국 서버 개발자의 핵심 가치는 <a>항상 동작하는, 신뢰할 수 있는 서비스</a>를 만드는 데 있다고 생각합니다.


<hr>

### 최근 읽은 기술 문서나 아티클 중 인상 깊었던 내용을 설명하시오.
(2025.08.01) 최근 읽은 기술 문서는 ResearchGate의 “QUICPot: A HTTP/3 Protocol Honeypot”이다. 이 문서는 HTTP/3 기반 QUIC 프로토콜로 Honeypot을 설계하여 취약점 탐지와 공격 패턴 분석에 활용하는 방법을 다룬다. 기존 TCP 기반과 달리 QUIC은 UDP 기반 구조와 TLS 1.3 내장을 통해 초기 연결 지연을 줄이고, 보안 계층을 기본 포함해 효율적인 보안 테스트가 가능하다. 
이를 통해 HTTP/3가 성능뿐 아니라 보안 대응 측면에서도 활용 가치가 높음을 알게 되었으며, 향후 대규모 트래픽과 보안 요구가 공존하는 서비스 설계 시 참고할 계획이다.